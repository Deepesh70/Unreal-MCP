"""
Template Renderer — Renders Blueprint schemas into C++ code via Jinja2.

Takes a validated Blueprint object, resolves types, and renders
the .h and .cpp templates into strings.
"""

from __future__ import annotations
from pathlib import Path
from jinja2 import Environment, FileSystemLoader, ChainableUndefined

from unreal_mcp.codegen.schema import Blueprint
from unreal_mcp.codegen.type_mapper import resolve_type, get_required_includes
from unreal_mcp.config.settings import UE_PROJECT_NAME


# ── Template directory ───────────────────────────────────────────────
_TEMPLATE_DIR = Path(__file__).parent.parent / "templates"


def _build_project_api(project_name: str) -> str:
    """Build the PROJECT_API macro, e.g. MYPROJECT_API."""
    return f"{project_name.upper()}_API"


def _prepare_context(blueprint: Blueprint) -> dict:
    """
    Convert a Blueprint schema into the template rendering context.

    Resolves all friendly types → UE types and collects required includes.
    """
    # Resolve variable types
    resolved_vars = []
    all_types = []
    for var in blueprint.variables:
        ue_type = resolve_type(var.type)
        all_types.append(var.type)
        resolved_vars.append({
            "name": var.name,
            "cpp_type": ue_type.cpp_type,
            "default_value": var.default or ue_type.default,
            "category": var.category,
            "editable": var.editable,
            "tooltip": var.tooltip,
        })

    # Resolve function types
    resolved_funcs = []
    for func in blueprint.functions:
        ret_type = resolve_type(func.return_type)
        all_types.append(func.return_type)

        params = []
        for p in func.params:
            p_type = resolve_type(p.type)
            all_types.append(p.type)
            params.append(f"{p_type.cpp_type} {p.name}")

        resolved_funcs.append({
            "name": func.name,
            "cpp_return_type": ret_type.cpp_type,
            "param_string": ", ".join(params) if params else "",
            "body": func.body,
            "callable": func.callable,
            "description": func.description,
        })

    # Collect all required includes from types
    type_includes = get_required_includes(all_types)
    extra_includes = list(set(type_includes + blueprint.extra_includes))

    return {
        "class_name": blueprint.class_name,
        "parent_class": blueprint.parent_class,
        "description": blueprint.description or f"{blueprint.class_name} — generated by Unreal MCP",
        "project_api": _build_project_api(UE_PROJECT_NAME),
        "variables": resolved_vars,
        "functions": resolved_funcs,
        "tick_enabled": blueprint.tick_enabled,
        "tick_body": blueprint.tick_body,
        "begin_play_body": blueprint.begin_play_body,
        "constructor_body": blueprint.constructor_body,
        "extra_includes": extra_includes,
    }


def render_header(blueprint: Blueprint) -> str:
    """Render the .h header file for a Blueprint."""
    env = Environment(
        loader=FileSystemLoader(str(_TEMPLATE_DIR)),
        keep_trailing_newline=True,
        trim_blocks=True,
        lstrip_blocks=True,
        undefined=ChainableUndefined,
    )
    template = env.get_template("base_actor.h.j2")
    context = _prepare_context(blueprint)
    return template.render(**context)


def render_source(blueprint: Blueprint) -> str:
    """Render the .cpp source file for a Blueprint."""
    env = Environment(
        loader=FileSystemLoader(str(_TEMPLATE_DIR)),
        keep_trailing_newline=True,
        trim_blocks=True,
        lstrip_blocks=True,
        undefined=ChainableUndefined,
    )
    template = env.get_template("base_actor.cpp.j2")
    context = _prepare_context(blueprint)
    return template.render(**context)


def render_both(blueprint: Blueprint) -> tuple[str, str]:
    """Render both .h and .cpp files. Returns (header_code, source_code)."""
    return render_header(blueprint), render_source(blueprint)
